<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Enfusion Script API: Replicating entities, components and hierarchies</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Enfusion Script API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Replicating entities, components and hierarchies </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#CreationOfRplNode">Creation of RplNode</a></li>
<li class="level1"><a href="#Hierarchies">Hierarchies</a></li>
<li class="level1"><a href="#Prefabs">Prefabs</a></li>
<li class="level1"><a href="#ProblematicSituations">Problematic situations</a><ul><li class="level2"><a href="#ProblematicSituations_NoComponentRoot">Prefab root does not have RplComponent</a></li>
<li class="level2"><a href="#ProblematicSituations_NoComponentParent">Parent entity is not RplNode</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>While it is possible to use <code><a class="el" href="interfaceRplNode.html">RplNode</a></code> for replication of just about anything (see <a class="el" href="Page_Replication_RplNode.html">RplNode</a> for more on this), in most cases, people deal with entities and components.</p>
<p><code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> is component that provides glue between replication and system of entities and components. It does this by creating <code><a class="el" href="interfaceRplNode.html">RplNode</a></code>, inserting entities and components into <code><a class="el" href="interfaceRplNode.html">RplNode</a></code>, then registering <code><a class="el" href="interfaceRplNode.html">RplNode</a></code> in replication. <b>Only entities or components whose replication layout is not empty (contains at least one replicated property, RPC, or replication callback) will be inserted. Everything else will be ignored by replication and cannot be referenced through it (eg. using <code><a class="el" href="interfaceRplId.html" title="Replication item identifier.">RplId</a></code>).</b></p>
<p>Base implementation of <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> is in <code>gamelib::BaseRplComponent</code>, however each game typically provides its own implementation derived from this base with game-specific changes. It is recommended to name this game-specific implementation <a class="el" href="interfaceRplComponent.html">RplComponent</a> to avoid confusion, but you should consult game documentation to find out what the name is, as well as what (if any) differences there are compared to default behavior described in this document.</p>
<p><code>RplComponents</code> impose some limitations on prefab structure and manipulation of entities spawned as part of hierarchy. Because of this, it is recommended that also people who don't normally deal with replication and only create prefabs and manage prefab structure and inheritance, have at least basic understanding of rules and examples described in this document.</p>
<h1><a class="anchor" id="CreationOfRplNode"></a>
Creation of RplNode</h1>
<p>Simply put, <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> during its <code>EOnInit</code> will start by visiting its owner entity (and its components), then recursively visit children of this entity (and their components), collecting all replicated entities or components it finds. Recursive search does not enter entities with <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code>, as those are part of another <code><a class="el" href="interfaceRplNode.html">RplNode</a></code>. Any entities and components that do not use replication system (no RPCs and no replicated properties) will not be part of created <code><a class="el" href="interfaceRplNode.html">RplNode</a></code>.</p>
<p>While above process may appear simple at first, it affects quite a lot and it is important that people working with replication intuitively understand how items are grouped into nodes, as that limits what they can and cannot do at runtime. To make all of this easier to understand, it is best show it on some examples. Let's first look at a simple entity with some components:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="464" height="218"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>Here we have an entity A with 4 components: r, a, b and c. Component r is <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code>, which will create the <code><a class="el" href="interfaceRplNode.html">RplNode</a></code> instance and fill it with replicated items. Components b and c are not replicated (they do not have any RPCs or replicated state) and so they are not part of created <code><a class="el" href="interfaceRplNode.html">RplNode</a></code>. <code><a class="el" href="interfaceRplNode.html">RplNode</a></code> in replication hierarchy will then contain 3 items: r, A and a. Notice how <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> is first item in the node, which means it is the head (see <a class="el" href="Page_Replication_RplNode.html">RplNode</a> for details).</p>
<h1><a class="anchor" id="Hierarchies"></a>
Hierarchies</h1>
<p>Let's first take a look at some simple entity hierarchy and how it will translate into node:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_4.svg" width="507" height="307"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>Once again, first item in the node is <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> r1. We then collect replicated items from the hierarchy and insert them into the node as well, while ignoring items which are not replicated. Important to notice is that entity hierarchy itself is not reflected in the node structure. Node is, after all, just a flat list of items. Notice how, even though entity C is not replicated, its replicated component e was still added to the node.</p>
<p>Hierarchies with just one <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> on root entity will always produce one node consisting of flattened list of replicated items. Things become more interesting when there are are multiple <code>RplComponents</code> present in the hierarchy:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_5.svg" width="571" height="338"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>By adding component r2 to entity B, we have created a new node r2, which is child of node r1 (previously node r). This allows us to detach entity B (node r2) from entity A (node r1) at runtime. However, entity C must always remain child of entity A, because they are part of the same node that cannot be modified after it has been inserted into replication.</p>
<p>One more example that demonstrates a bit more complicated hierarchy. Notice how hierarchy of entities and hierarchy of nodes can look quite different:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_6.svg" width="862" height="578"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p><code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> sets up and maintains replication hierarchy by listening for changes in entity hierarchy and performing similar operations on node hierarchy in replication. This behavior is controlled using <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> property "Parent Node From Parent Entity", which is currently turned on by default. When turned off, replication node managed by this component will not have its parent replication node modified to match node of new parent entity. We can demonstrate this on above example. If we were to turn off "Parent Node from Parent Entity" on <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> r2, we would create two independent replication hierarchies:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_7.svg" width="354" height="231"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>This can be a powerful tool when optimizing streaming. Replication hierarchy is streamed all at once and, for larger hierarchies, this can lead to very large messages and expensive instantiation on clients. It may also lead to streaming unnecessary data to clients. Large buildings may have objects placed inside which are unlikely to become visible for particular client due to distance or obstacles, but if those objects are children of this building (in replication hierarchy), they will always be streamed together with the building itself. By turning off "Parent Node From Parent Entity" on these objects, scheduler can control them independently from building itself. As a consequence, one must keep in mind that presence of parent entity on client does not necessarily imply presence of children that turn this setting off.</p>
<h1><a class="anchor" id="Prefabs"></a>
Prefabs</h1>
<p>Remember that you must not add or remove items from node after it has been inserted into replication system, but you can modify hierarchy of nodes themselves. This means that entities with <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> are movable parts of the hierarchy and can be removed or added as the game progresses. When new player joins an already running game ("join-in-progress", or JIP for short), we need to communicate these changes. To keep traffic low, server sends only limited information:</p><ol type="1">
<li>Which entity from which prefab to spawn to recreate each node.</li>
<li>How to connect these nodes into hierarchy.</li>
</ol>
<h1><a class="anchor" id="ProblematicSituations"></a>
Problematic situations</h1>
<h2><a class="anchor" id="ProblematicSituations_NoComponentRoot"></a>
Prefab root does not have RplComponent</h2>
<p>One problem that can arise is prefab where root entity does not have <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code>:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_8.svg" width="464" height="288"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>As you can see, replication system does not know anything about entity A and its components, as they are not part of the <code><a class="el" href="interfaceRplNode.html">RplNode</a></code>. This causes problems when spawning this prefab at runtime (or during JIP), because we can't associate <code><a class="el" href="interfaceRplNode.html">RplNode</a></code> with resource GUID of the prefab from which it came.</p>
<p>There are two possible solutions in this case:</p><ol type="1">
<li>Move <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> from entity B to entity A.</li>
<li>Add <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> to entity A, in addition to entity B. This is required if you need to change who is parent of entity B at runtime.</li>
</ol>
<h2><a class="anchor" id="ProblematicSituations_NoComponentParent"></a>
Parent entity is not RplNode</h2>
<p>You should be careful when intermediate entities between two entities with <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> do not form nodes themselves. An example case of this problem:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_9.svg" width="504" height="368"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>This might look like it should work at first, and in many cases it will. Problems will arise when this hierarchy is streamed to the client as part of JIP. Replication can only reconstruct the hierarchy of nodes, but that does not have information about entity B being child of entity A, so the hierarchy will be set up differently between client and server, leading to desync. While on its own this is not an issue for replication, it may cause problems in game code. For example, sending position relative to parent from server to client will cause client to interpret that position against different parent, giving wrong results.</p>
<p>More insidious case of this would arise if entity B was not replicated (no replicated state or RPCs), in which case, it wouldn't even exist in the <code><a class="el" href="interfaceRplNode.html">RplNode</a></code> r1. It wouldn't have <a class="el" href="interfaceRplId.html" title="Replication item identifier.">RplId</a> assigned in which case user code can't correct the hierarchy either, because there is no way for server to address this entity on client and set it as correct parent.</p>
<p>Possible solutions are:</p><ol type="1">
<li>Add <code><a class="el" href="interfaceRplComponent.html">RplComponent</a></code> to entity B, making it a node itself and thus getting replication hierarchy closer to entity hierarchy.</li>
<li>Make entity C direct child of entity A. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
